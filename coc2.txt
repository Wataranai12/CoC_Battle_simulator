<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoCæ¢ç´¢è€…æ¨¡æ“¬æˆ¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+JP:wght@400;700&display=swap');
        body {
            font-family: 'Noto Sans JP', 'Inter', sans-serif;
            background-color: #f7f7f7;
        }
        .hp-bar-container {
            height: 8px;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }
        .hp-bar {
            height: 100%;
            transition: width 0.3s ease-in-out, background-color 0.3s ease-in-out;
            border-radius: 4px;
        }
    </style>
</head>
<body class="p-4 md:p-8 bg-gray-50 min-h-screen">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold text-center text-red-700 mb-6 border-b-2 pb-2 border-red-200">
            CoCæ¢ç´¢è€… æ¨¡æ“¬æˆ¦ (ç¬¬6ç‰ˆ)
        </h1>

        <!-- ãƒ‡ãƒ¼ã‚¿å…¥åŠ›ã‚¨ãƒªã‚¢ -->
        <div class="bg-white p-4 rounded-xl shadow-lg border border-gray-200 mb-6">
            <h2 class="text-lg font-bold text-gray-800 mb-2">æ¢ç´¢è€…ãƒ‡ãƒ¼ã‚¿å…¥åŠ› (JSONå½¢å¼)</h2>
            <p class="text-sm text-gray-600 mb-3">ã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹å ´åˆã¯ã€JSONé…åˆ—ã§å…¥åŠ›ã—ã€Œãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚æœªå…¥åŠ›ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
            <textarea id="character-input" rows="5" class="w-full p-2 border border-gray-300 rounded-lg font-mono text-sm" placeholder="ä¾‹: [{ name: 'ã‚­ãƒ£ãƒ©1', dex: 15, ... }, { name: 'ã‚­ãƒ£ãƒ©2', ... }]"></textarea>
            <button id="load-data-button" onclick="initializeGame(true)" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 mt-2">
                ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ï¼†ãƒªã‚»ãƒƒãƒˆ
            </button>
        </div>

        <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
        <div id="status-container" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <!-- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚«ãƒ¼ãƒ‰ãŒæŒ¿å…¥ã•ã‚Œã‚‹ -->
        </div>

        <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã¨ãƒ­ã‚° -->
        <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200">
            <div class="flex flex-col sm:flex-row justify-between items-center mb-4 space-y-3 sm:space-y-0">
                <p id="round-info" class="text-xl font-semibold text-gray-700"></p>
                <div class="flex flex-wrap items-center space-x-2">
                    <!-- ã‚·ãƒ§ãƒƒã‚¯ãƒ­ãƒ¼ãƒ«è¨­å®š -->
                    <div class="flex items-center space-x-2 bg-gray-100 p-2 rounded-lg">
                        <label for="shock-roll-toggle" class="text-sm font-medium text-gray-700">ã‚·ãƒ§ãƒƒã‚¯ãƒ­ãƒ¼ãƒ«:</label>
                        <input type="checkbox" id="shock-roll-toggle" class="form-checkbox h-5 w-5 text-red-600 rounded" checked>
                    </div>

                    <button id="next-round-button" onclick="nextRound()" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 disabled:opacity-50">
                        æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ã¸
                    </button>
                    <button id="reset-button" onclick="initializeGame(false)" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300">
                        ãƒªã‚»ãƒƒãƒˆ
                    </button>
                    <button id="save-log-button" onclick="saveLog()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 disabled:opacity-50" disabled>
                        ãƒ­ã‚°ä¿å­˜ (.txt)
                    </button>
                    <button id="analyze-button" onclick="analyzeCombat()" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 disabled:opacity-50" disabled>
                        âœ¨ æˆ¦é—˜åˆ†æãƒ»è§£èª¬
                    </button>
                </div>
            </div>

            <!-- ãƒ­ã‚°è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
            <h2 class="text-xl font-bold text-gray-800 border-b pb-2 mb-2">æˆ¦é—˜ãƒ­ã‚°</h2>
            <div id="log-container" class="h-96 bg-gray-100 p-4 rounded-lg overflow-y-auto text-sm space-y-1">
                <p class="text-gray-500">æˆ¦é—˜é–‹å§‹ï¼ã€Œãƒªã‚»ãƒƒãƒˆã€ã¾ãŸã¯ã€Œãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã€ã‚’è¡Œã£ã¦ãã ã•ã„ã€‚</p>
            </div>
        </div>
    </div>

    <script>
        // CoCç¬¬6ç‰ˆã®æ¢ç´¢è€…ãƒ‡ãƒ¼ã‚¿ã¨ç‰¹æ®Šãƒ«ãƒ¼ãƒ«ã®å®šç¾©
        // NOTE: æ¯’ä»˜ãç°ªã¯æ¯’ (POT12) ã®åŠ¹æœã¨ã—ã¦ CONÃ—5 å¤±æ•—ã§æ¯’çŠ¶æ…‹ã€æ¶²ä½“çª’ç´ ã¯ CONÃ—5 å¤±æ•—ã§æ¬¡ã®æˆ¦é—˜æŠ€èƒ½-20ã€MAæˆåŠŸã¯ãƒ€ãƒ¡ãƒ¼ã‚¸2å€ã€éŠƒã¯FN 99ã€96ä»¥ä¸Šã¯ãƒ•ã‚¡ãƒ³ãƒ–ãƒ«(è»¢å€’/æ¬¡ã‚¿ãƒ¼ãƒ³è¡Œå‹•ä¸èƒ½)ã€‚
        const defaultCharacters = [
            {
                name: "æ—©ç´ ç…¤æµ (ã•ã® ã°ã„ã‚Šã‚…ã†)",
                dex: 12, con: 16, hp: 14, db: "1d4", maxHp: 14, isAlive: true,
                weapons: [
                    { name: "å›é¿", skill: 94, type: "evade" },
                    // ãƒ¡ã‚¤ãƒ³æ­¦å™¨ (MAã®è‡ªå‹•é©ç”¨å¯¾è±¡)
                    { name: "è‚‰åˆ‡ã‚ŠåŒ…ä¸", skill: 90, damage: "1d6", type: "melee", isMain: true }, 
                    { name: "åŒ…ä¸", skill: 90, damage: "1d4", type: "melee" }, // ã‚µãƒ–æ­¦å™¨
                    { name: "ãƒãƒ¼ã‚·ãƒ£ãƒ«ã‚¢ãƒ¼ãƒ„", skill: 67, damage: "1d3", type: "ma" }
                ],
                combatSkillPenalty: 0, isSkippingTurn: false, isUnconscious: false, isMainWeaponBroken: false
            },
            {
                name: "åŒ–é‡ æ¥“æœˆ (ã‚ã ã—ã® ã‹ã¥ã)",
                dex: 14, con: 10, hp: 10, db: "0", maxHp: 10, isAlive: true,
                weapons: [
                    { name: "å›é¿", skill: 82, type: "evade" },
                    { name: "ä»•è¾¼ã¿æ–", skill: 95, damage: "1d6", type: "melee", isMain: true },
                    // æ•…éšœãƒŠãƒ³ãƒãƒ¼ 99
                    { name: ".38å£å¾„ã‚ªãƒ¼ãƒˆãƒãƒãƒƒã‚¯", skill: 90, damage: "1d10", type: "gun", ammo: 6, maxAmmo: 6, attackCount: 1, isMain: false, malfunction: 99, isBroken: false } 
                ],
                isReloading: false, combatSkillPenalty: 0, isSkippingTurn: false, isUnconscious: false
            },
            {
                name: "ç›®ä¼¯ æ™´å‘Š (ã‚ã˜ã‚ ã¯ã‚‹ã¤ã)",
                dex: 14, con: 9, hp: 12, db: "1d4", maxHp: 12, isAlive: true,
                weapons: [
                    { name: "å›é¿", skill: 68, type: "evade" },
                    { name: "ç°ª(ãƒŠã‚¤ãƒ•)", skill: 80, damage: "1d4", type: "melee", isMain: true },
                    { name: "ç°ª(æ¯’ä»˜ã)", skill: 80, damage: "1d4", type: "melee", special: "poison" }, 
                    { name: "ç°ª(æŠ•ã’)", skill: 71, damage: "1d4", type: "throw", range: 10 },
                    { name: "ç°ª(æŠ•ã’æ¯’ä»˜ã)", skill: 71, damage: "1d4", type: "throw", special: "poison" } 
                ],
                combatSkillPenalty: 0, isSkippingTurn: false, isUnconscious: false, isPoisoned: false
            },
            {
                name: "ä¹æ¡(ä»®) (ãã˜ã‚‡ã†)",
                dex: 11, con: 13, hp: 12, db: "0", maxHp: 12, isAlive: true,
                weapons: [
                    { name: "å›é¿", skill: 72, type: "evade" },
                    { name: "ãƒŠã‚¤ãƒ•", skill: 90, damage: "1d4+2", type: "melee", isMain: true },
                    { name: "æ¶²ä½“çª’ç´ ", skill: 90, damage: "1d6", type: "throw", special: "nitrogen", isMain: true }
                ],
                combatSkillPenalty: 0, isSkippingTurn: false, isUnconscious: false
            }
        ];

        let characters = [];
        let round = 0;
        let isCombatFinished = false;
        let fullCombatLog = ""; // ãƒ­ã‚°ä¿å­˜ãƒ»åˆ†æç”¨ã®å®Œå…¨ãƒ­ã‚°

        const logContainer = document.getElementById('log-container');
        const nextRoundButton = document.getElementById('next-round-button');
        const roundInfo = document.getElementById('round-info');
        const saveLogButton = document.getElementById('save-log-button');
        const analyzeButton = document.getElementById('analyze-button');

        // LLMé–¢é€£ã®è¨­å®š (APIã‚­ãƒ¼ã¯Canvasç’°å¢ƒã§è‡ªå‹•æä¾›ã•ã‚Œã‚‹ãŸã‚ç©ºæ–‡å­—åˆ—)
        const LLM_API_KEY = "";
        const LLM_MODEL_NAME = "gemini-2.5-flash-preview-09-2025";
        const LLM_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${LLM_MODEL_NAME}:generateContent?key=${LLM_API_KEY}`;

        // =======================================================================
        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        // =======================================================================

        /**
         * ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°: ãƒ€ã‚¤ã‚¹ãƒ­ãƒ¼ãƒ«
         * @param {string} diceString - ä¾‹: '1d100', '1d4+2', '1d6+1d4'
         * @returns {object} ãƒ­ãƒ¼ãƒ«çµæœ { total: number, rolls: string }
         */
        function rollDice(diceString) {
            let total = 0;
            const parts = diceString.split('+');
            const rolls = [];

            for (const part of parts) {
                const cleanPart = part.trim().toLowerCase();
                if (cleanPart.includes('d')) {
                    const [count, sides] = cleanPart.split('d').map(Number);
                    for (let i = 0; i < count; i++) {
                        const roll = Math.floor(Math.random() * sides) + 1;
                        total += roll;
                        rolls.push(`${roll}(${count}d${sides})`);
                    }
                } else if (cleanPart) {
                    const number = Number(cleanPart);
                    total += number;
                    rolls.push(`${number}`);
                }
            }

            return { total, rolls: rolls.join('+') };
        }

        /**
         * ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’UIã«è¿½åŠ 
         * @param {string} message - è¡¨ç¤ºã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
         * @param {string} type - 'info', 'success', 'error', 'damage', 'special', 'death', 'llm'
         * @param {boolean} isLLM - LLMåˆ†æãƒ­ã‚°ã‹ã©ã†ã‹
         */
        function logMessage(message, type = 'info') {
            const logItem = document.createElement('p');
            logItem.classList.add('p-2', 'rounded-lg', 'text-gray-800', 'leading-relaxed');

            switch (type) {
                case 'success':
                    logItem.classList.add('bg-green-100', 'text-green-800', 'font-semibold');
                    break;
                case 'damage':
                    logItem.classList.add('bg-red-100', 'text-red-800', 'font-semibold');
                    break;
                case 'special':
                    logItem.classList.add('bg-yellow-100', 'text-yellow-800', 'font-semibold');
                    break;
                case 'error':
                    logItem.classList.add('bg-red-200', 'text-red-900', 'font-bold');
                    break;
                case 'death':
                    logItem.classList.add('bg-red-500', 'text-white', 'font-bold', 'text-lg');
                    break;
                case 'llm':
                    logItem.classList.add('bg-purple-100', 'text-purple-800', 'font-bold', 'border-l-4', 'border-purple-500');
                    break;
                case 'info':
                default:
                    logItem.classList.add('bg-gray-200');
                    break;
            }

            const prefix = {
                success: 'âœ… æˆåŠŸ:',
                damage: 'ğŸ’¥ æ”»æ’ƒ:',
                special: 'âœ¨ ç‰¹æ®Š:',
                error: 'ğŸš¨ ã‚¨ãƒ©ãƒ¼:',
                death: 'ğŸ’€ æˆ¦é—˜ä¸èƒ½:',
                llm: 'ğŸ—£ï¸ GMè§£èª¬:',
                info: 'â¡ï¸'
            }[type];

            logItem.innerHTML = `<span class="font-bold">${prefix}</span> ${message}`;
            logContainer.appendChild(logItem); // ãƒ­ã‚°ã‚’ä¸‹ã«è¿½åŠ 
            logContainer.scrollTop = logContainer.scrollHeight; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ä¸€ç•ªä¸‹ã«
            
            // å®Œå…¨ãƒ­ã‚°ã«ã‚‚è¿½åŠ ï¼ˆUIè¡¨ç¤ºç”¨ã‚¿ã‚°ã¯å‰Šé™¤ï¼‰
            const plainMessage = logItem.textContent || logItem.innerText;
            fullCombatLog += plainMessage + '\n';
        }

        /**
         * ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã‚’æ›´æ–°
         */
        function updateStatus() {
            const container = document.getElementById('status-container');
            container.innerHTML = '';
            characters.forEach(char => {
                const hpPercent = char.hp <= 0 ? 0 : Math.min(100, (char.hp / char.maxHp) * 100);
                let hpColor = 'bg-green-500';
                if (hpPercent <= 50) hpColor = 'bg-yellow-500';
                if (hpPercent <= 20) hpColor = 'bg-red-500';

                const statusClass = char.isAlive ? 'border-green-400' : 'border-red-400 opacity-50';
                const statusText = char.isAlive ? 'ç”Ÿå­˜ä¸­' : 'æˆ¦é—˜ä¸èƒ½';

                // å›é¿æŠ€èƒ½å€¤ã‚’å–å¾—
                const evadeWeapon = char.weapons.find(w => w.type === 'evade');
                const evadeSkill = evadeWeapon ? evadeWeapon.skill : 0;

                // çŠ¶æ…‹è¡¨ç¤º
                const stateIndicators = [];
                if (char.combatSkillPenalty !== 0) stateIndicators.push(`<span class="text-red-600 font-bold">æŠ€èƒ½-20</span>`);
                if (char.isReloading) stateIndicators.push(`<span class="text-yellow-600 font-bold">ãƒªãƒ­ãƒ¼ãƒ‰ä¸­</span>`);
                if (char.isPoisoned) stateIndicators.push(`<span class="text-purple-600 font-bold">æ¯’çŠ¶æ…‹</span>`);
                if (char.isSkippingTurn) stateIndicators.push(`<span class="text-orange-600 font-bold">è¡Œå‹•ä¸èƒ½</span>`);
                if (char.isUnconscious) stateIndicators.push(`<span class="text-red-700 font-bold">æ°—çµ¶</span>`);

                const stateText = stateIndicators.length > 0 ? stateIndicators.join(' / ') : 'æ­£å¸¸';

                // ä½¿ç”¨å¯èƒ½ãªæˆ¦é—˜ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æŠ½å‡º
                const combatOptions = char.weapons
                    .filter(w => w.isMain || w.type === 'ma' || w.special === 'nitrogen' || w.special === 'poison' || w.type === 'gun' || w.type === 'throw')
                    .map(w => {
                        let skill = w.skill !== undefined ? w.skill : "N/A";
                        let actualSkill = skill;
                        if (w.type !== 'evade') {
                            actualSkill = (w.skill || 0) + char.combatSkillPenalty;
                        }
                        
                        let info = '';
                        if (w.type === 'gun') {
                            if (w.isBroken) {
                                info = `: <span class="text-sm text-red-500">æ•…éšœ (FN: ${w.malfunction})</span>`;
                            } else if (w.ammo !== undefined) {
                                info = ` (${w.ammo}/${w.maxAmmo} å¼¾)`;
                            }
                        } else if (w.special === 'poison') {
                            info = ` (æ¯’ä»˜ä¸)`;
                        } else if (w.special === 'nitrogen') {
                            info = ` (æŠ€èƒ½-20ãƒ‡ãƒãƒ•)`;
                        }
                        
                        return `${w.name} (${actualSkill}%)` + info;
                    })
                    .join(' / ');

                const cardHtml = `
                    <div class="bg-white p-4 rounded-lg shadow-md border-b-4 ${statusClass}">
                        <h3 class="text-lg font-bold text-gray-800">${char.name} <span class="text-sm font-normal text-gray-500">(${statusText})</span></h3>
                        <p class="text-sm text-gray-600">DEX: ${char.dex} / CON: ${char.con} / DB: +${char.db}</p>
                        <p class="text-sm text-gray-600">å›é¿: ${evadeSkill}%</p>
                        <p class="text-sm text-gray-600">çŠ¶æ…‹: ${stateText}</p>
                        <p class="text-sm text-gray-600">æˆ¦é—˜ã‚ªãƒ—ã‚·ãƒ§ãƒ³: ${combatOptions}</p>
                        
                        <!-- HPãƒãƒ¼ -->
                        <div class="mt-2">
                            <div class="text-xs font-mono">${char.hp}/${char.maxHp} HP</div>
                            <div class="hp-bar-container">
                                <div class="hp-bar ${hpColor}" style="width: ${hpPercent}%;"></div>
                            </div>
                        </div>
                    </div>
                `;
                container.innerHTML += cardHtml;
            });

            roundInfo.textContent = `ãƒ©ã‚¦ãƒ³ãƒ‰: ${round}`;
        }

        // =======================================================================
        // æˆ¦é—˜ãƒ­ã‚¸ãƒƒã‚¯
        // =======================================================================

        /**
         * æ”»æ’ƒå¯¾è±¡ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠï¼ˆè‡ªåˆ†è‡ªèº«ã¨æˆ¦é—˜ä¸èƒ½è€…ã‚’é™¤ãï¼‰
         * @param {object} attacker - æ”»æ’ƒè€…ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
         * @param {Array<object>} allCharacters - å…¨ã¦ã®æ¢ç´¢è€…ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
         * @returns {object | null} ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
         */
        function selectTarget(attacker, allCharacters) {
            const potentialTargets = allCharacters.filter(c => c.name !== attacker.name && c.isAlive);
            if (potentialTargets.length === 0) return null;
            
            // 1d4ã§ãƒãƒ§ã‚¤ã‚¹ã¨ã„ã†ãƒ«ãƒ¼ãƒ«ã ãŒã€ç”Ÿå­˜è€…ãŒå°‘ãªã„å ´åˆã¯ãã®ä¸­ã‹ã‚‰å‡ç­‰ã«ãƒ©ãƒ³ãƒ€ãƒ é¸æŠ
            const index = Math.floor(Math.random() * potentialTargets.length);
            return potentialTargets[index];
        }
        
        /**
         * ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ«ã¨DBåŠ ç®—/æ¸›ç®—
         * @param {string} damageString - åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒ€ã‚¤ã‚¹æ–‡å­—åˆ— (ä¾‹: '1d6', '1d4+2')
         * @param {string} dbString - DBãƒ€ã‚¤ã‚¹æ–‡å­—åˆ— (ä¾‹: '1d4', '0')
         * @param {boolean} isMelee - è¿‘æ¥æ”»æ’ƒã‹ã©ã†ã‹
         * @returns {object} æœ€çµ‚ãƒ€ãƒ¡ãƒ¼ã‚¸ { totalDamage: number, detail: string }
         */
        function calculateDamage(damageString, dbString, isMelee = true) {
            const baseDamage = rollDice(damageString);
            let dbDamage = 0;
            
            // è¿‘æ¥æ”»æ’ƒ (melee/ma) ã§DBãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿åŠ ç®—
            if (isMelee && dbString !== "0") {
                dbDamage = rollDice(dbString).total;
            }

            const totalDamage = baseDamage.total + dbDamage;
            return { totalDamage, detail: `${baseDamage.rolls}${dbDamage > 0 ? ` + DB(${dbDamage})` : ''}` };
        }

        /**
         * ã‚·ãƒ§ãƒƒã‚¯ãƒ­ãƒ¼ãƒ«åˆ¤å®š
         * @param {object} target - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
         * @param {number} damageTaken - å—ã‘ãŸãƒ€ãƒ¡ãƒ¼ã‚¸
         */
        function checkShockRoll(target, damageTaken) {
            const shockRollToggle = document.getElementById('shock-roll-toggle');
            if (!shockRollToggle.checked) return; // ã‚·ãƒ§ãƒƒã‚¯ãƒ­ãƒ¼ãƒ«ãŒç„¡åŠ¹ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—

            const halfHp = target.maxHp / 2;
            if (damageTaken >= halfHp) {
                logMessage(`${target.name} ã¯ä¸€æ’ƒã§æœ€å¤§HPã®åŠåˆ† (${halfHp}) ä»¥ä¸Šã®ãƒ€ãƒ¡ãƒ¼ã‚¸ (${damageTaken}) ã‚’å—ã‘ãŸãŸã‚ã€ã‚·ãƒ§ãƒƒã‚¯ãƒ­ãƒ¼ãƒ«ã‚’è¡Œã„ã¾ã™ (CONÃ—5: ${target.con * 5}%)ã€‚`, 'special');
                const conRoll = rollDice('1d100').total;
                const conCheck = target.con * 5;

                if (conRoll > conCheck) {
                    // å¤±æ•— -> æ°—çµ¶ã¨æˆ¦é—˜ä¸èƒ½
                    target.isUnconscious = true;
                    target.isAlive = false; // æ°—çµ¶ã¯å³æˆ¦é—˜ä¸èƒ½ã¨ã™ã‚‹ãƒã‚¦ã‚¹ãƒ«ãƒ¼ãƒ«
                    logMessage(`CONÃ—5åˆ¤å®š (${conCheck}%) ã«å¤±æ•— (D100: ${conRoll})ã€‚ ${target.name} ã¯æ°—çµ¶ã—ã€æˆ¦é—˜ä¸èƒ½ã¨ãªã‚Šã¾ã—ãŸï¼`, 'death');
                } else {
                    // æˆåŠŸ
                    logMessage(`CONÃ—5åˆ¤å®š (${conCheck}%) ã«æˆåŠŸ (D100: ${conRoll})ã€‚è€ãˆãã£ãŸï¼`, 'success');
                }
            }
        }

        /**
         * ç‰¹æ®ŠåŠ¹æœåˆ¤å®šï¼ˆæ¶²ä½“çª’ç´ /æ¯’ï¼‰
         * @param {object} target - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
         * @param {string} type - 'nitrogen' or 'poison'
         */
        function checkSpecialEffect(target, type) {
            const conCheck = target.con * 5;
            logMessage(`${target.name} ã¯ ${type === 'nitrogen' ? 'æ¶²ä½“çª’ç´ ' : 'æ¯’'} ã«ã‚ˆã‚‹ç‰¹æ®ŠåŠ¹æœåˆ¤å®šã‚’è¡Œã„ã¾ã™ (CONÃ—5: ${conCheck}%)ã€‚`, 'special');
            
            // ãƒ­ãƒ¼ãƒ«ã«æŒ‡æ•°çš„ãƒãƒƒã‚¯ã‚ªãƒ•ã‚’é©ç”¨
            async function retryConRoll(retries = 0) {
                const conRoll = rollDice('1d100').total;

                if (conRoll > conCheck) {
                    // å¤±æ•—
                    if (type === 'nitrogen') {
                        target.combatSkillPenalty = -20;
                        logMessage(`CONÃ—5åˆ¤å®š (${conCheck}%) ã«å¤±æ•— (D100: ${conRoll})ã€‚æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã€æˆ¦é—˜æŠ€èƒ½ã«<span class="text-red-600 font-bold">-20</span>ã®ãƒšãƒŠãƒ«ãƒ†ã‚£ï¼`, 'special');
                    } else if (type === 'poison') {
                        target.isPoisoned = true;
                        // æ¯’ã®åŠ¹æœã¯å˜ç´”åŒ–ã®ãŸã‚ã€ã“ã“ã§ã¯çŠ¶æ…‹ä»˜ä¸ã®ã¿ã€‚
                        logMessage(`CONÃ—5åˆ¤å®š (${conCheck}%) ã«å¤±æ•— (D100: ${conRoll})ã€‚${target.name} ã¯<span class="text-purple-600 font-bold">æ¯’çŠ¶æ…‹</span>ã«ãªã‚Šã¾ã—ãŸï¼`, 'special');
                    }
                } else {
                    // æˆåŠŸ
                    logMessage(`CONÃ—5åˆ¤å®š (${conCheck}%) ã«æˆåŠŸ (D100: ${conRoll})ã€‚ãƒšãƒŠãƒ«ãƒ†ã‚£ãªã—ã€‚`, 'success');
                }
            }

            // éåŒæœŸã§å®Ÿè¡Œ
            retryConRoll();
        }

        /**
         * æ”»æ’ƒå‡¦ç†
         * @param {object} attacker - æ”»æ’ƒè€…
         * @param {object} target - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
         * @param {object} weapon - ä½¿ç”¨æ­¦å™¨
         */
        function performAttack(attacker, target, weapon) {
            let log = `${attacker.name} ãŒ ${target.name} ã¸ ${weapon.name} ã§æ”»æ’ƒã€‚`;

            // å®Ÿéš›ã®æŠ€èƒ½å€¤ (ãƒ‡ãƒãƒ•é©ç”¨)
            const actualSkill = (weapon.skill || 0) + attacker.combatSkillPenalty;

            const d100 = rollDice('1d100').total;
            log += ` D100ãƒ­ãƒ¼ãƒ«: ${d100} (ç›®æ¨™å€¤: ${actualSkill}%)ã€‚`;

            // ãƒ•ã‚¡ãƒ³ãƒ–ãƒ«åˆ¤å®š (96ä»¥ä¸Š)
            if (d100 >= 96) {
                logMessage(`${log} <span class="text-orange-600 font-bold">ãƒ•ã‚¡ãƒ³ãƒ–ãƒ«ï¼</span> æ”»æ’ƒå¤±æ•—ã€‚è»¢å€’ã—ã¦è‡ªåˆ†ã«1ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã€æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã¯è¡Œå‹•ä¸èƒ½ã«ãªã‚Šã¾ã™ã€‚`, 'error');
                attacker.hp = Math.max(0, attacker.hp - 1);
                attacker.isSkippingTurn = true;
                if (attacker.hp <= 0 && attacker.isAlive) {
                    attacker.isAlive = false;
                    logMessage(`${attacker.name} ã¯è‡ªæ»…ã«ã‚ˆã‚Šæˆ¦é—˜ä¸èƒ½ã¨ãªã‚Šã¾ã—ãŸã€‚`, 'death');
                }
                return;
            }

            // æˆåŠŸåˆ¤å®š
            const isCritical = d100 <= actualSkill && d100 <= 5; // ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«: æŠ€èƒ½å€¤ä»¥ä¸‹ ã‹ã¤ 5ä»¥ä¸‹
            const isSuccess = d100 <= actualSkill;

            let finalDamage = 0;
            let damageDetails = "";
            let damageMultiplier = 1;
            let targetEvaded = false;

            if (isSuccess) {
                log += `<span class="text-green-600 font-bold">${isCritical ? 'ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«æˆåŠŸ' : 'æˆåŠŸ'}</span>ã€‚`;
                
                // ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã®å ´åˆã€å›é¿ä¸å¯ã€ãƒ€ãƒ¡ãƒ¼ã‚¸2å€
                if (isCritical) {
                    log += `<span class="text-red-600 font-bold">ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¯å›é¿ã§ãã¾ã›ã‚“ï¼</span> ãƒ€ãƒ¡ãƒ¼ã‚¸2å€ï¼`;
                    damageMultiplier = 2;
                } else {
                    // é€šå¸¸æˆåŠŸã®å ´åˆã€å›é¿åˆ¤å®š
                    const evadeWeapon = target.weapons.find(w => w.type === 'evade');
                    const evadeSkill = evadeWeapon ? evadeWeapon.skill : 0;
                    const evadeD100 = rollDice('1d100').total;
                    log += ` ${target.name} ã¯å›é¿ (${evadeSkill}%) ã‚’è©¦ã¿ã¾ã™ (D100: ${evadeD100})ã€‚`;

                    if (evadeD100 <= evadeSkill) {
                        targetEvaded = true;
                        logMessage(`${log} <span class="text-green-600 font-bold">å›é¿æˆåŠŸï¼</span> ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¾ã›ã‚“ã€‚`, 'success');
                        return; // æ”»æ’ƒçµ‚äº†
                    } else {
                        log += `<span class="text-red-600 font-bold">å›é¿å¤±æ•—ã€‚</span>`;
                    }
                }

                // æ”»æ’ƒå‘½ä¸­ (å›é¿å¤±æ•— or ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«)
                const damageRoll = calculateDamage(weapon.damage, attacker.db, weapon.type === 'melee' || weapon.type === 'ma');
                finalDamage = damageRoll.totalDamage;
                damageDetails = damageRoll.detail;

                // æ—©ç´ ç…¤æµã®MAå‡¦ç† (è¿‘æ¥æ”»æ’ƒã®ã¿)
                if (attacker.name.includes("æ—©ç´ ç…¤æµ") && (weapon.type === 'melee' || weapon.type === 'throw')) {
                    const maWeapon = attacker.weapons.find(w => w.name === "ãƒãƒ¼ã‚·ãƒ£ãƒ«ã‚¢ãƒ¼ãƒ„");
                    if (maWeapon) {
                        const maD100 = rollDice('1d100').total;
                        log += ` MAåˆ¤å®š (${maWeapon.skill}%) (D100: ${maD100})ã€‚`;
                        if (maD100 <= maWeapon.skill) {
                            damageMultiplier *= 2;
                            log += `<span class="text-yellow-600 font-bold">MAæˆåŠŸï¼</span> ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒ2å€ã«ãªã‚Šã¾ã™ã€‚`;
                        } else {
                            log += `MAå¤±æ•—ã€‚`;
                        }
                    }
                }

                finalDamage *= damageMultiplier;
                target.hp = Math.max(0, target.hp - finalDamage);

                logMessage(`${log} **${finalDamage}** ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ (å…ƒD:${damageDetails} x ${damageMultiplier}) ${target.name} HP: ${target.hp}/${target.maxHp}`, 'damage');

                // ã‚·ãƒ§ãƒƒã‚¯ãƒ­ãƒ¼ãƒ«åˆ¤å®š
                checkShockRoll(target, finalDamage);

                // ç‰¹æ®ŠåŠ¹æœåˆ¤å®š (æ”»æ’ƒå‘½ä¸­æ™‚ã®ã¿)
                if (weapon.special === 'nitrogen') {
                    checkSpecialEffect(target, 'nitrogen');
                } else if (weapon.special === 'poison') {
                    checkSpecialEffect(target, 'poison');
                }

                // éŠƒã®ãƒªãƒ­ãƒ¼ãƒ‰ãƒ»æ•…éšœåˆ¤å®š
                if (weapon.type === 'gun') {
                    weapon.ammo--;
                    // æ•…éšœåˆ¤å®š (99ã¾ãŸã¯100ã§æ•…éšœ)
                    if (d100 >= weapon.malfunction) {
                        weapon.isBroken = true;
                        logMessage(`${weapon.name} ã¯ ${d100} ã‚’å‡ºã—ã€æ•…éšœ (FN:${weapon.malfunction}) ã—ã¾ã—ãŸã€‚ä»¥é™ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚`, 'error');
                    } else if (weapon.ammo <= 0) {
                        attacker.isReloading = true;
                        logMessage(`${weapon.name} ã®å¼¾åˆ‡ã‚Œã€‚æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã¯ãƒªãƒ­ãƒ¼ãƒ‰ã«å°‚å¿µã—ã¾ã™ã€‚`, 'special');
                    }
                }

                // æˆ¦é—˜ä¸èƒ½ãƒã‚§ãƒƒã‚¯
                if (target.hp <= 0 && target.isAlive) {
                    target.isAlive = false;
                    logMessage(`${target.name} ã¯åŠ›å°½ãã€æˆ¦é—˜ä¸èƒ½ã¨ãªã‚Šã¾ã—ãŸã€‚`, 'death');
                }

            } else {
                // æ”»æ’ƒå¤±æ•— (é€šå¸¸å¤±æ•—)
                logMessage(`${log} <span class="text-red-600 font-bold">å¤±æ•—ã€‚</span> æ”»æ’ƒã¯å¤–ã‚Œã¾ã—ãŸã€‚`, 'error');
            }
        }

        /**
         * 1ãƒ©ã‚¦ãƒ³ãƒ‰ã®æˆ¦é—˜å‡¦ç†
         */
        function nextRound() {
            if (isCombatFinished) {
                logMessage('æˆ¦é—˜ã¯çµ‚äº†ã—ã¾ã—ãŸã€‚ãƒªã‚»ãƒƒãƒˆã—ã¦ãã ã•ã„ã€‚', 'info');
                return;
            }

            round++;
            logMessage(`======== ãƒ©ã‚¦ãƒ³ãƒ‰ ${round} é–‹å§‹ ========`, 'info');

            // 1. ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹æ™‚ã®å‡¦ç† (ãƒ‡ãƒãƒ•è§£é™¤ã€ãƒªãƒ­ãƒ¼ãƒ‰ã€è¡Œå‹•ä¸èƒ½è§£é™¤)
            characters.filter(c => c.isAlive).forEach(char => {
                // æ¶²ä½“çª’ç´ ãƒ‡ãƒãƒ•è§£é™¤ (é©ç”¨ã¯1ã‚¿ãƒ¼ãƒ³ã®ã¿)
                char.combatSkillPenalty = 0; 
                
                // æ¯’ãƒ€ãƒ¡ãƒ¼ã‚¸ (ã‚·ãƒ³ãƒ—ãƒ«åŒ–ã®ãŸã‚ã€ä»Šå›ã¯çŠ¶æ…‹ä»˜ä¸ã®ã¿ã§ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ã¯çœç•¥)
                
                // è¡Œå‹•ä¸èƒ½è§£é™¤
                if (char.isSkippingTurn) {
                    char.isSkippingTurn = false;
                    logMessage(`${char.name} ã¯ä½“å‹¢ã‚’ç«‹ã¦ç›´ã—ã€æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ã‹ã‚‰è¡Œå‹•å¯èƒ½ã§ã™ã€‚`, 'info');
                }

                // ãƒªãƒ­ãƒ¼ãƒ‰å‡¦ç†
                if (char.isReloading) {
                    const gun = char.weapons.find(w => w.type === 'gun');
                    if (gun) {
                        gun.ammo = gun.maxAmmo;
                        char.isReloading = false;
                        logMessage(`${char.name} ã¯ãƒªãƒ­ãƒ¼ãƒ‰ã‚’å®Œäº†ã—ã¾ã—ãŸ (${gun.name}: ${gun.maxAmmo}ç™º)ã€‚`, 'success');
                    }
                }
            });

            // 2. è¡Œå‹•é †ã®æ±ºå®š (DEXé †ã€åŒå€¤ã¯ãƒ©ãƒ³ãƒ€ãƒ )
            let activeCharacters = characters.filter(c => c.isAlive);
            activeCharacters.sort((a, b) => {
                if (a.dex !== b.dex) {
                    return b.dex - a.dex; // DEXé™é †
                }
                return Math.random() - 0.5; // DEXåŒå€¤ã¯ãƒ©ãƒ³ãƒ€ãƒ 
            });

            // 3. å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®è¡Œå‹•
            for (const attacker of activeCharacters) {
                if (!attacker.isAlive || attacker.isSkippingTurn || attacker.isReloading) {
                    if (attacker.isSkippingTurn) {
                        logMessage(`${attacker.name} ã¯ãƒ•ã‚¡ãƒ³ãƒ–ãƒ«ã®ãƒšãƒŠãƒ«ãƒ†ã‚£ã«ã‚ˆã‚Šã€ã“ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã¯è¡Œå‹•ã§ãã¾ã›ã‚“ã€‚`, 'special');
                    } else if (attacker.isReloading) {
                        logMessage(`${attacker.name} ã¯ãƒªãƒ­ãƒ¼ãƒ‰ä¸­ã®ãŸã‚ã€ã“ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã¯è¡Œå‹•ã§ãã¾ã›ã‚“ã€‚`, 'special');
                    }
                    continue;
                }

                const target = selectTarget(attacker, characters);
                if (!target) break; // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒã„ãªã‘ã‚Œã°çµ‚äº†

                // æ­¦å™¨é¸æŠãƒ­ã‚¸ãƒƒã‚¯
                let weapon = null;
                const availableWeapons = attacker.weapons.filter(w => {
                    if (w.type === 'gun' && (w.isBroken || w.ammo <= 0)) return false;
                    return w.isMain || w.special;
                });

                // æ—©ç´ ç…¤æµ: è‚‰åˆ‡ã‚ŠåŒ…ä¸ (ãƒ¡ã‚¤ãƒ³) å„ªå…ˆ
                if (attacker.name.includes("æ—©ç´ ç…¤æµ")) {
                    weapon = availableWeapons.find(w => w.name === "è‚‰åˆ‡ã‚ŠåŒ…ä¸");
                    if (!weapon) weapon = availableWeapons.find(w => w.name === "åŒ…ä¸");
                    if (!weapon) weapon = availableWeapons.find(w => w.type === 'melee');
                }
                // åŒ–é‡ æ¥“æœˆ: éŠƒãŒä½¿ãˆã‚Œã°éŠƒã€ãã†ã§ãªã‘ã‚Œã°ä»•è¾¼ã¿æ–
                else if (attacker.name.includes("åŒ–é‡ æ¥“æœˆ")) {
                    const gun = availableWeapons.find(w => w.type === 'gun');
                    if (gun && !gun.isBroken && gun.ammo > 0) {
                        weapon = gun;
                    } else {
                        weapon = availableWeapons.find(w => w.name === "ä»•è¾¼ã¿æ–");
                    }
                }
                // ä¹æ¡(ä»®): æ¶²ä½“çª’ç´ å„ªå…ˆã€ãªã‘ã‚Œã°ãƒŠã‚¤ãƒ•
                else if (attacker.name.includes("ä¹æ¡(ä»®)")) {
                    weapon = availableWeapons.find(w => w.name === "æ¶²ä½“çª’ç´ ");
                    if (!weapon) weapon = availableWeapons.find(w => w.name === "ãƒŠã‚¤ãƒ•");
                }
                // ç›®ä¼¯ æ™´å‘Š: æ¯’ä»˜ãæŠ•ã’ç°ªå„ªå…ˆã€ãªã‘ã‚Œã°é€šå¸¸ãƒŠã‚¤ãƒ•
                else if (attacker.name.includes("ç›®ä¼¯ æ™´å‘Š")) {
                    weapon = availableWeapons.find(w => w.name === "ç°ª(æŠ•ã’æ¯’ä»˜ã)");
                    if (!weapon) weapon = availableWeapons.find(w => w.name === "ç°ª(æ¯’ä»˜ã)");
                    if (!weapon) weapon = availableWeapons.find(w => w.name === "ç°ª(ãƒŠã‚¤ãƒ•)");
                }
                
                // æœ€çµ‚çš„ã«æ­¦å™¨ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚‰ã€æœ€åˆã®åˆ©ç”¨å¯èƒ½ãªæ­¦å™¨ã‚’ä½¿ã†
                if (!weapon && availableWeapons.length > 0) {
                    weapon = availableWeapons[0];
                }
                
                if (weapon) {
                    performAttack(attacker, target, weapon);
                } else {
                    logMessage(`${attacker.name} ã¯æœ‰åŠ¹ãªæ­¦å™¨ãŒãªã„ãŸã‚ã€æ”»æ’ƒã§ãã¾ã›ã‚“ã§ã—ãŸã€‚`, 'error');
                }
            }

            // 4. æˆ¦é—˜çµ‚äº†åˆ¤å®š
            activeCharacters = characters.filter(c => c.isAlive);
            if (activeCharacters.length <= 1) {
                isCombatFinished = true;
                if (activeCharacters.length === 1) {
                    logMessage(`======== æˆ¦é—˜çµ‚äº†: å‹è€… ${activeCharacters[0].name} ========`, 'death');
                } else {
                    logMessage('======== æˆ¦é—˜çµ‚äº†: ç”Ÿå­˜è€…ãªã— (ç›¸è¨ã¡) ========', 'death');
                }
                nextRoundButton.disabled = true;
                saveLogButton.disabled = false;
                analyzeButton.disabled = false; // åˆ†æãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
            }

            updateStatus();
        }

        // =======================================================================
        // åˆæœŸåŒ–ãƒ»UIé–¢é€£é–¢æ•°
        // =======================================================================

        /**
         * ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–
         * @param {boolean} useInputData - å…¥åŠ›ã‚¨ãƒªã‚¢ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã©ã†ã‹
         */
        function initializeGame(useInputData = false) {
            let dataToUse = defaultCharacters;
            logContainer.innerHTML = '';
            fullCombatLog = '';
            
            if (useInputData) {
                const inputArea = document.getElementById('character-input').value;
                try {
                    const customData = JSON.parse(inputArea);
                    if (Array.isArray(customData) && customData.every(c => c.name && c.dex)) {
                        dataToUse = customData;
                        logMessage('ã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚', 'info');
                    } else {
                        logMessage('ç„¡åŠ¹ãªã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒ¼ã‚¿å½¢å¼ã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚', 'error');
                    }
                } catch (e) {
                    if (inputArea.trim() !== "") {
                        logMessage('JSONãƒ‡ãƒ¼ã‚¿ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚', 'error');
                        console.error("JSON Parse Error:", e);
                    }
                }
            } else {
                logMessage('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿ã§ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚', 'info');
            }

            // ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼ã—ã¦çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            characters = JSON.parse(JSON.stringify(dataToUse));
            
            // çŠ¶æ…‹å¤‰æ•°ã®åˆæœŸåŒ–
            characters.forEach(char => {
                char.hp = char.maxHp || char.hp; // HPã‚’æœ€å¤§å€¤ã«æˆ»ã™
                char.isAlive = true;
                char.isReloading = false;
                char.combatSkillPenalty = 0;
                char.isSkippingTurn = false;
                char.isUnconscious = false;
                char.isPoisoned = false;

                // éŠƒã®çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                const gun = char.weapons.find(w => w.type === 'gun');
                if (gun) {
                    gun.isBroken = false;
                    gun.ammo = gun.maxAmmo;
                }
            });

            round = 0;
            isCombatFinished = false;
            nextRoundButton.disabled = false;
            saveLogButton.disabled = true;
            analyzeButton.disabled = true;

            updateStatus();
        }

        /**
         * ãƒ­ã‚°ã‚’ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜
         */
        function saveLog() {
            if (fullCombatLog.trim() === "") {
                logMessage('ä¿å­˜ã™ã‚‹ãƒ­ã‚°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚', 'error');
                return;
            }

            const blob = new Blob([fullCombatLog], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `CoC_battle_log_R${round}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logMessage('æˆ¦é—˜ãƒ­ã‚°ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚', 'success');
        }

        /**
         * LLMã‚’ä½¿ç”¨ã—ã¦æˆ¦é—˜ã‚’åˆ†æãƒ»è§£èª¬
         */
        async function analyzeCombat() {
            if (!isCombatFinished || fullCombatLog.trim() === "") {
                logMessage('æˆ¦é—˜ãŒçµ‚äº†ã—ã¦ã„ã‚‹ã‹ã€ãƒ­ã‚°ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚', 'error');
                return;
            }

            const log = fullCombatLog;
            analyzeButton.disabled = true;
            analyzeButton.textContent = 'åˆ†æä¸­...';
            
            // LLMã¸ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¨­å®š
            const systemPrompt = `ã‚ãªãŸã¯ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±TRPGã®ç†Ÿç·´ã‚²ãƒ¼ãƒ ãƒã‚¹ã‚¿ãƒ¼ã§ã™ã€‚æä¾›ã•ã‚ŒãŸæˆ¦é—˜ãƒ­ã‚°ã‚’åˆ†æã—ã€ä»¥ä¸‹ã®ç‚¹ã‚’ç››ã‚Šè¾¼ã‚“ã ã€ãƒ‰ãƒ©ãƒãƒãƒƒã‚¯ã§ç‰©èªæ€§ã®ã‚ã‚‹è§£èª¬ã‚’æ—¥æœ¬èªã§è¡Œã£ã¦ãã ã•ã„ã€‚
1. æˆ¦ã„ã®ã‚¯ãƒ©ã‚¤ãƒãƒƒã‚¯ã‚¹ã‚„è»¢æ©Ÿã¨ãªã£ãŸç¬é–“ã€‚
2. ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚„ãƒ•ã‚¡ãƒ³ãƒ–ãƒ«ãªã©ã®ãƒ€ã‚¤ã‚¹ãƒ­ãƒ¼ãƒ«ã®é‹å‘½çš„ãªå½±éŸ¿ã€‚
3. æ¶²ä½“çª’ç´ ã€æ¯’ã€MAãªã©ã®ç‰¹æ®Šãªæ”»æ’ƒãŒæˆ¦é—˜ã«ä¸ãˆãŸå½±éŸ¿ã€‚
4. æœ€çµ‚çš„ãªå‹è€…ã¨æ•—å› ã®è€ƒå¯Ÿã€‚
è§£èª¬ã¯ä¸€ã¤ã®ã¾ã¨ã¾ã£ãŸæ®µè½ã§æ§‹æˆã—ã€æ„Ÿæƒ…è±Šã‹ã«èªã‚Šã‹ã‘ã¦ãã ã•ã„ã€‚`;

            const userQuery = `æˆ¦é—˜ãƒ­ã‚°: \n\n${log}\n\nã“ã®æˆ¦é—˜ã‚’è§£èª¬ã—ã¦ãã ã•ã„ã€‚`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            const maxRetries = 3;
            let currentRetry = 0;

            const fetchAnalysis = async () => {
                try {
                    const response = await fetch(LLM_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    const analysisText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (analysisText) {
                        logMessage('GMè§£èª¬ã®ç”Ÿæˆã«æˆåŠŸã—ã¾ã—ãŸã€‚', 'info');
                        logMessage(analysisText, 'llm');
                    } else {
                        logMessage('GMè§£èª¬ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚AIã‹ã‚‰ã®å¿œç­”ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                    }
                } catch (error) {
                    console.error("LLM API Error:", error);
                    if (currentRetry < maxRetries) {
                        currentRetry++;
                        const delay = Math.pow(2, currentRetry) * 1000; // 1s, 2s, 4s...
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return fetchAnalysis();
                    } else {
                        logMessage('æˆ¦é—˜åˆ†æã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ (APIã‚¨ãƒ©ãƒ¼)ã€‚', 'error');
                    }
                } finally {
                    analyzeButton.disabled = false;
                    analyzeButton.textContent = 'âœ¨ æˆ¦é—˜åˆ†æãƒ»è§£èª¬';
                }
            };
            
            fetchAnalysis();
        }

        // åˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ã«ã‚²ãƒ¼ãƒ ã‚’åˆæœŸåŒ–
        window.onload = () => {
            initializeGame(false);
        };
    </script>
</body>
</html>